#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <map>
#include <string>
#include "Lattice.hpp"

//***************************************************
// set - Defult constructor.
//***************************************************
Lattice::set::set() { }

//***************************************************
// set - Sets two integers arguments as member values.
//***************************************************
Lattice::set::set(int x, int y) : x(x), y(y) { }

//***************************************************
// set::operator < - Overloads < for set for use with 
//   other set objects.
//***************************************************
bool Lattice::set::operator < (const set& a) const {
	if (x != a.x) {
		return x < a.x;
	} else {
		return y < a.y;
	}
}
//***************************************************
// set::operator != - Overloads != for set for use with 
//   other set objects.
//***************************************************
bool Lattice::set::operator != (const set& a) const {
	return !(x == a.x && y == a.y);
}

//***************************************************
// Lattice - Constructs a lattice bassed on probability
//  'openProb', and dimentions 'dim'.
//***************************************************
Lattice::Lattice(double openProb, int dim, const int seed) : openProb(openProb), dim(dim) {
	/* object seeded with passed in value to avoid repetative rand() outcomes */
	srand(seed);

	/* Ceate 2D array */
	lattice = new int *[dim];
	for (int i = 0; i < dim; ++i) {
		lattice[i] = new int[dim];
	}

	/* Populate 2D array */
	for (int i = 0; i < dim; ++i) {
		for (int n = 0; n < dim; ++n) {
			lattice[i][n] = ((rand() % 100 + 1) / 100.0 <= openProb ? 1 : 0);
		}
	}
}

//***************************************************
// Lattice - Constructs a lattice bassed on data found
//  at a specified file location. No file data validation
//  is preformed.
//***************************************************
Lattice::Lattice(std::string input) {
	int row = 0;
	std::fstream in;
	in.open(input.c_str(), std::fstream::in);

	/* Get size of array */
	std::string inputLine;
	getline(in, inputLine);
	dim = inputLine.size()/2;

	/* Create 2D array */
	lattice = new int * [dim];
	for (int i = 0; i < dim; ++i) {
		lattice[i] = new int[dim];
	}

	do {	
		for (int i = 0; i < dim; ++i) {
			lattice[row][i] = inputLine[i*2] - '0';
		}
		++row;
	} while (row < dim && getline(in, inputLine));
}

//***************************************************
// ~Lattice - Dealocates dynamicaly located memory.
//***************************************************
Lattice::~Lattice() {
	for (int i = 0; i < dim; ++i) {
		delete [] lattice[i];
	}

	delete [] lattice;
}

//***************************************************
// print - Prints the content of the objects lattice to
//  results.ppm, located in the working directory. White
//  squares are considered open, black squares are closed
//  while orange mean an open cell with a valid traversal 
//  path.
//***************************************************
void Lattice::print() {
	std::fstream out;
	out.open("results.ppm", std::fstream::out);

	if (!path.empty()) {
		colorGrid();
	}

	/* Print PPM header */
	out << "P3 \n#Print of lattice generated by Lattice.cpp \n"
	    << dim << ' ' << dim << " \n" << 255 << " \n";

	/* Print lattice to file */
	for (int i = 0; i < dim; ++i) {
		for (int n = 0; n < dim; ++n) {
			if (lattice[i][n] == 0) {
				out << std::setw(4) << 0 << std::setw(4) << 0 << std::setw(4) << 0 << (n == dim-1 ? "\n" : "");
			} else if (lattice[i][n] == 1) {
				out << std::setw(4) << 255 << std::setw(4) << 255 << std::setw(4) << 255 << (n == dim-1 ? "\n" : "");
			} else {
				out << std::setw(4) << 255 << std::setw(4) << 128 << std::setw(4) << 0 << (n == dim-1 ? "\n" : "");
			}
		}
	}
}

//***************************************************
// getRoot - Making use of the map 'path' and a passed 
//  in set, this function returns the root of a group
//  of contiguous cells. This is only to be preformed
//  'open' cells (those containing 1 or 100).
//***************************************************
Lattice::set Lattice::getRoot(const set& a) {
	set tempSet = a;
	
	while (path[tempSet] != tempSet) {
		tempSet = path[tempSet];
	}

	return tempSet;
}

//***************************************************
// unionFind - Scans a lattice and marks all groups of
//  contiguous cells with a common 'root' node. Connections
//  are stored inside the 'path' map with the key being
//  any given open node, and the result being the root
//  of the node of those around it. If a node is the root
//  of a contiguous group, its root is marked as itself.
//  The function returuns true if a path exists from the
//  top to the bottom of a lattice. Else false.
//***************************************************
bool Lattice::unionFind() { 
	for (int i = 0; i < dim; ++i) { 
		for (int n = 0; n < dim; ++n) {
			bool noRight = true, noDown = true;
	
			/* Closed cell, do nothing */
			if (lattice[i][n] == 0) {
				continue;
			} 

			/* Right connection found */
			if (n != dim-1 && lattice[i][n] && lattice[i][n+1]) {
				set point1(n, i), point2(n+1, i);
				noRight = false;
				if (path.count(point1) == 0 && path.count(point2) != 0) {
					path[point1] = getRoot(point2);
				} else if (path.count(point1) != 0 && path.count(point2) == 0) {
					path[point2] = getRoot(point1);
				} else if (path.count(point1) && path.count(point2)) {
					path[getRoot(point2)] = getRoot(point1);
					path[point2] = getRoot(point1);
				} else {
					path[point1] = point1;
					path[point2] = point1;
				}
			}

			/* Downwards connection found */
			if (i != dim-1 && lattice[i][n] && lattice[i+1][n]) {
				set point1(n, i), point2(n, i+1);
				noDown = false;
				if (path.count(point1) == 0 && path.count(point2) != 0) {
					path[point1] = getRoot(point2);
				} else if (path.count(point1) != 0 && path.count(point2) == 0) {
					path[point2] = getRoot(point1);
				} else if (path.count(point1) && path.count(point2)) {
					path[getRoot(point2)] = getRoot(point1);
					path[point2] = getRoot(point1);
				} else {
					path[point1] = point1;
					path[point2] = point1;
				}
			} 

			/* Single cell found */
			if (noRight && noDown && (i == 0 ? true : lattice[i-1][n] == 0) && (n == 0 ? true : lattice[i][n-1] == 0)) {
				path[set(n, i)] = set(n, i);
			}
		} 
	}	

	/* Set all children to point to head */
	for (std::map<set,set>::iterator iter = path.begin(); iter != path.end(); ++iter) {
		iter->second = getRoot(iter->second);
	}

	/* Check for full path */
	std::map<set, set> found;
	for (std::map<set,set>::iterator iter = path.begin(); iter != path.end(); ++iter) {
		if (iter->first.y == 0 || iter->first.y == dim-1 && iter->first.x != -1) {
			if (found.count(iter->second) == 0) {
				found[iter->second].x = found[iter->second].y = false;
			}
			if (iter->first.y == 0) { 
				found[iter->second].x = true; 
			} else { 
				found[iter->second].y = true; 
			}
			if (found[iter->second].x == true && found[iter->second].y == true) {
				return true;
			}
		}
	}

	return false;
}

//***************************************************
// colorGrid - Locates a path of open nodes from the top  
//  to bottom of a lattice, then gives them the value 
//  100. 100 is a flag that denotes, when printed, that 
//  they are apart of an 'open' path, and are therefor 
//  collored oragne (instead of white).
//***************************************************
void Lattice::colorGrid() {
	const int COLOR = 100;
	set cordKey;

	std::map<set, set> found;
	for (std::map<set,set>::iterator iter = path.begin(); iter != path.end(); ++iter) {
		if (iter->first.y == 0 || iter->first.y == dim-1) {
			if (found.count(iter->second) == 0) {
				found[iter->second].x =  found[iter->second].y = false;
			}
			if (iter->first.y == 0) { 
				found[iter->second].x = true;
			} else { 
				found[iter->second].y = true; 
			}
			if (found[iter->second].x == true && found[iter->second].y == true) {
				cordKey = getRoot(iter->second);
				break;
			}
		}
	}

	for (std::map<set,set>::iterator iter = path.begin(); iter != path.end(); ++iter) {
		if (getRoot(iter->second).y == cordKey.y && getRoot(iter->second).x == cordKey.x) {
			lattice[iter->first.y][iter->first.x] = COLOR;
		}
	}
}

//***************************************************
// clusters - returns an integer, 'clusters', 
//  the count of individual contiguous segments of open
//  cells that are found in a given lattice.
//***************************************************
int Lattice::clusters() {
	int clusters = 0;
	std::map<set, bool> found;
	for (std::map<set,set>::iterator iter = path.begin(); iter != path.end(); ++iter) {
		if (found.count(iter->second) == 0) {
			found[iter->second] = true;
			++clusters;
		}
	}

	return clusters;
}
